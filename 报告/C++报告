C++一般用cin和cout输入输出,也可用标准C的输入输出（要包括头文件stdio.h）
C++的I，O涉及到iostream文件，所以程序开始就要#include <iostream>
#include编译指令在编译程序时把对应文件替换该行指令
<> 先去系统目录找，再到当前目录找，一般用于 stdio.h、stdlib.h 等标准头文件
" "则相反，一般用于自定义的头文件
iostream.h继承C语言的标准库文件，未引入名字空间定义，不用using namespace
iostream则需要using namespace std，否则后续输入输出要加上std::
开发过程中尽量避免引入整个命名空间，直接命名空间::函数避免命名空间污染
std::endl 输出一个换行符后会立即刷新缓冲区(将其立即显示屏幕上)

存储在静态数据区的变量会在程序刚开始运行时就完成唯一的一次初始化。
int fun()
{
    static int count = 10; // 首次進入函數，变量 count 被初始化为 10，并接着自减 1，以后每次进入该函数，count 的值是上一次函数运行之后的值
    return count--;        // 不会被再次初始化为10，仅进行自减 1 的操作；若不用static，只能使用全局变量达到同样的功能。
}
静态全局变量有全局作用域，如果程序有多个文件，則僅作用于定义它的文件里，不能作用到其它文件，即被static关键字修饰过的变量具有文件作用域。
这样即使两个不同的源文件都定义了相同名字的静态全局变量，它们也是不同的变量。

A、若全局变量仅在单个C文件中访问，可将其改为静态全局变量，降低模块间的耦合度；
B、若全局变量仅由单个函数访问，可将其改为该函数的静态局部变量，降低模块间的耦合度；
C、函数的返回值若为指针类型时，则必须以static的局部变量的地址作为返回值，若为auto类型，则返回为错指针。

&：取值對應的地址
*：尋地址對應的值

指針與變量引用
聲明變量時，
1.“類型 *變量1”：聲明指針變量。若後面“=&變量2”，則指針變量1的值是變量2的地址。
int  var=32;     // 声明int类型变量var
int * ptr;    // 声明指针变量ptr
int ** pptr;  // 声明二级指针变量pptr
ptr = &var;   
// 先用 & 获取变量var的地址，再把该地址赋给指针变量ptr，
//ptr就是var的地址，*ptr就==*(&var)即var地址的值也就是*ptr==var
pptr = &ptr;
//*pptr就==*(&ptr)即ptr的值也就是*pptr==&var，**pptr就是var的值
//同理，pptr就是ptr的地址亦var地址的地址，而&pptr就是ptr地址的地址
注：值的地址的地址一般是值的地址前一個變量的寬度，對應內存中的地址減少0x4
c++标准库中I/O类对操作符<<重载，在遇到字符型指针时，会将其当做字符串名来处理，输出指针所指向的字符串直到’\0’停止。
要輸出某一個字符的地址，需要把char类型的指针强行转换为void类型的指针 (void *)。
https://blog.csdn.net/weixin_41783910/article/details/108441788

2.“類型& 變量1=變量2”：聲明引用變量1，是變量2的別名(引用必须在创建时被初始化)。如int& b=a,b是a的別名，a，b任一個變了，另一個也變。

以引用作为参数的函数，可以把变量传入，但不能传入常量。
參數傳遞可以傳遞實參，指針和引用https://www.runoob.com/cplusplus/passing-parameters-by-references.html
其中，傳遞實參時會將數據創建一個副本，效率低.在函數定義裡用.來選擇成員，對數據任何修改只是修改副本，通過return返回數據。
傳遞指針不創建副本，效率高，在函數定義裡用—>來選擇成員。同時為避免空指針，在定義裡必須先檢查非空。
傳遞引用也不創建副本，效率高，但在函數定義裡用.來選擇成員。又引用必有对象，所以不用检查非空。
傳遞指針後，在函數定義裡對數據操作時要對指針操作（變量前加＋*）而不是指針指向的地址，傳遞前則要先将变量的地址赋值给声明的指针，增加了变量的个数，綜上，引用優於指针優於實參。

struct和class
struct是一個數據結構的實現體，默認public，可以在定義時用{}初始化
而class是一個對象的實現體，默認private，無法用{}初始化
algorithm

OOP
抽象：隐藏不相关的具體的實現细节，只关注共同的本质特征。
封装：将一些关键的属性和针对属性的通用操作捆绑在一起，封装成一个类。
继承：
多态：
